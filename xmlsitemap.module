<?php
// $Id$

/**
 * @defgroup xmlsitemap XML sitemap: create sitemaps.org sitemaps.
 */

/**
 * @file
 * Main file for the xmlsitemap module.
 */

/**
 * The maximum number of links in one sitemap chunk file.
 */
define('XMLSITEMAP_MAX_SITEMAP_LINKS', 50000);

/**
 * The maximum filesize of a sitemap chunk file.
 */
define('XMLSITEMAP_MAX_SITEMAP_FILESIZE', 10485760);

/**
 * The maximum number of links in one sitemap index file.
 */
define('XMLSITEMAP_MAX_SITEMAP_CHUNKS', 1000);

define('XMLSITEMAP_FREQUENCY_YEARLY', 31449600); // 60 * 60 * 24 * 7 * 52
define('XMLSITEMAP_FREQUENCY_MONTHLY', 2419200); // 60 * 60 * 24 * 7 * 4
define('XMLSITEMAP_FREQUENCY_WEEKLY', 604800); // 60 * 60 * 24 * 7
define('XMLSITEMAP_FREQUENCY_DAILY', 86400); // 60 * 60 * 24
define('XMLSITEMAP_FREQUENCY_HOURLY', 3600); // 60 * 60
define('XMLSITEMAP_FREQUENCY_ALWAYS', 60);

/**
 * Implements hook_help().
 */
function xmlsitemap_help($path, $arg) {
  $output = '';

  switch ($path) {
    case 'admin/help#xmlsitemap':
      $sitemaps = xmlsitemap_get_sitemaps(TRUE);
      $output .= format_plural(count($sitemaps), 'Your sitemap is located at: !sitemaps', 'Your sitemaps are located at: !sitemaps', array('!sitemaps' => theme('item_list', $sitemaps)));
      break;
    case 'admin/config/search/xmlsitemap':
      break;
    case 'admin/config/search/xmlsitemap/rebuild':
      $output .= '<p>' . t("This action rebuilds your site's XML sitemap and regenerates the cached files, and may be a lengthy process. If you just installed XML sitemap, this can be helpful to import all your site's content into the sitemap. Otherwise, this should only be used in emergencies.") . '</p>';
  }

  // Use a static variable because this code may be called more than once.
  static $checked = FALSE;
  if (!$checked && arg(0) == 'admin' && strpos($path, 'xmlsitemap') !== FALSE) {
    $checked = TRUE;
    module_load_install('xmlsitemap');
    if (user_access('administer site configuration') && $messages = xmlsitemap_check_status()) {
      drupal_set_message(t('One or more problems were detected with your XML sitemap configuration. Check the <a href="@status-report">status report</a> for more information.<br />!list', array('@status-report' => url('admin/reports/status'), '!list' => theme('item_list', array('items' => $messages)))), 'warning', FALSE);
    }
    module_load_include('inc', 'xmlsitemap');
    if ($blurb = _xmlsitemap_get_blurb()) {
      $output .= '<div class="form-item"><div class="description">' . $blurb . '</div></div>';
    }
  }

  return $output;
}

/**
 * Implements hook_perm().
 */
function xmlsitemap_permission() {
  return array(
    'administer xmlsitemap' => array(
      'title' => t('Administer XML sitemap settings.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function xmlsitemap_menu() {
  $items['admin/config/search/xmlsitemap'] = array(
    'title' => 'XML sitemap',
    'description' => 'Configure the XML sitemap.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xmlsitemap_settings_form'),
    'access arguments' => array('administer xmlsitemap'),
    'file' => 'xmlsitemap.admin.inc',
  );
  $items['admin/config/search/xmlsitemap/settings'] = array(
    'title' => 'Settings',
    'access arguments' => array('administer xmlsitemap'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'xmlsitemap.admin.inc',
    'weight' => -10,
  );
  $items['admin/config/search/xmlsitemap/rebuild'] = array(
    'title' => 'Rebuild',
    'description' => 'Rebuild the site map.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xmlsitemap_rebuild_form'),
    'access arguments' => array('administer xmlsitemap'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'xmlsitemap.admin.inc',
    'weight' => 10,
  );

  $items['sitemap.xml'] = array(
    'page callback' => 'xmlsitemap_output_chunk',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'xmlsitemap.pages.inc',
  );
  $chunks = xmlsitemap_get_chunk_count();
  if ($chunks > 1) {
    for ($i = 1; $i <= $chunks; $i++) {
      $items['sitemap-' . $i . '.xml'] = array(
        'page callback' => 'xmlsitemap_output_chunk',
        'page arguments' => array((string) $i),
        'access arguments' => array('access content'),
        'type' => MENU_CALLBACK,
        'file' => 'xmlsitemap.pages.inc',
      );
    }
  }
  $items['sitemap.xsl'] = array(
    'page callback' => 'xmlsitemap_output_xsl',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'file' => 'xmlsitemap.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_cron().
 */
function xmlsitemap_cron() {
  // If there were no new or changed links, skip.
  if (!variable_get('xmlsitemap_regenerate_needed', FALSE)) {
    return;
  }

  // If the minimum sitemap lifetime hasn't been passed, skip.
  $lifetime = REQUEST_TIME - variable_get('xmlsitemap_generated_last', 0);
  if ($lifetime < variable_get('xmlsitemap_minimum_lifetime', 0)) {
    return;
  }

  // Regenerate the sitemap XML files.
  module_load_include('inc', 'xmlsitemap');
  xmlsitemap_regenerate();
}

/**
 * Implements hook_xmlsitemap_links().
 */
function xmlsitemap_xmlsitemap_links() {
  // Frontpage link.
  $links[] = array(
    'type' => 'frontpage',
    'id' => 0,
    'loc' => '',
  );
  return $links;
}

/**
 * Implements hook_xmlsitemap_link_alter().
 */
function xmlsitemap_xmlsitemap_link_alter(&$link) {
  // Alter the frontpage priority.
  if ($link['type'] == 'frontpage' || $link['loc'] == '' || $link['loc'] == variable_get('site_frontpage', 'node')) {
    $link['priority'] = xmlsitemap_var('frontpage_priority');
    $link['changefreq'] = xmlsitemap_var('frontpage_changefreq');
  }
}

/**
 * Implements hook_robotstxt().
 */
function xmlsitemap_robotstxt() {
  module_load_include('inc', 'xmlsitemap');
  $sitemaps = xmlsitemap_get_sitemaps();
  foreach ($sitemaps as $index => $sitemap) {
    $sitemaps[$index] = 'Sitemap: ' . $sitemap;
  }
  return $sitemaps;
}

/**
 * Get an array of the current site's sitemaps.
 *
 * @param $links
 *   A boolean if TRUE, the array elements will be HTML links.
 * @return
 *   An array of sitemaps.
 */
function xmlsitemap_get_sitemaps($links = FALSE) {
  static $sitemaps = array();

  if (!$sitemaps) {
    $url_options = xmlsitemap_get_url_options();
    $sitemap_languages = xmlsitemap_var('languages');
    natsort($sitemap_languages);

    foreach ($sitemap_languages as $language) {
      $url_options['language'] = xmlsitemap_language_load($language);
      $sitemap = url('sitemap.xml', $url_options);
      $sitemaps[$language] = $links ? l($sitemap, $sitemap) : $sitemap;
    }
  }

  return $sitemaps;
}

/**
 * Return a list of commonly used parameters for url() used by XML sitemap.
 *
 * @see url()
 */
function xmlsitemap_get_url_options($options = array()) {
  return $options + array(
    'absolute' => TRUE,
    'base_url' => xmlsitemap_var('base_url'),
  );
}

/**
 * Determine the frequency of updates to a link.
 *
 * @param $interval
 *   An interval value in seconds.
 * @return
 *   A string representing the update frequency according to the sitemaps.org
 *   protocol.
 */
function xmlsitemap_get_changefreq($interval) {
  if ($interval <= 0 || !is_numeric($interval)) {
    return FALSE;
  }

  foreach (xmlsitemap_get_changefreq_options() as $value => $frequency) {
    if ($interval <= $value) {
      return $frequency;
    }
  }

  return 'never';
}

/**
 * Get the current number of sitemap chunks.
 */
function xmlsitemap_get_chunk_count($reset = FALSE) {
  static $chunks;
  if (!isset($chunks) || $reset) {
    $count = max(xmlsitemap_get_link_count($reset), 1);
    $chunks = ceil($count / xmlsitemap_get_chunk_size($reset));
  }
  return $chunks;
}

/**
 * Get the current number of sitemap links.
 */
function xmlsitemap_get_link_count($reset = FALSE) {
  static $count;
  if (!isset($count) || $reset) {
    $count = db_query("SELECT COUNT(id) FROM {xmlsitemap} WHERE access = 1 AND status = 1")->fetchField();
  }
  return $count;
}

/**
 * Get the sitemap chunk size.
 *
 * This function is useful with the chunk size is set to automatic as it will
 * calculate the appropriate value. Use this function instead of @code
 * xmlsitemap_var('chunk_size') @endcode when the actual value is needed.
 *
 * @param $reset
 *   A boolean to reset the saved, static result. Defaults to FALSE.
 * @return
 *   An integer with the number of links in each sitemap page.
 */
function xmlsitemap_get_chunk_size($reset = FALSE) {
  static $size;
  if (!isset($size) || $reset) {
    $size = xmlsitemap_var('chunk_size');
    if ($size === 'auto') {
      $count = max(xmlsitemap_get_link_count($reset), 1); // Prevent divide by zero.
      $size = min(ceil($count / 10000) * 5000, XMLSITEMAP_MAX_SITEMAP_LINKS);
    }
  }
  return $size;
}

/**
 * Recalculate the changefreq of a sitemap link.
 *
 * @param $link
 *   A sitemap link array.
 */
function xmlsitemap_recalculate_changefreq(&$link) {
  $link['changefreq'] = round((($link['changefreq'] * $link['changecount']) + (REQUEST_TIME - $link['lastmod'])) / ($link['changecount'] + 1));
  $link['changecount']++;
  $link['lastmod'] = REQUEST_TIME;
}

/**
 * Calculates the average interval between UNIX timestamps.
 *
 * @param $timestamps
 *   An array of UNIX timestamp integers.
 * @return
 *   An integer of the average interval.
 */
function xmlsitemap_calculate_changefreq($timestamps) {
  sort($timestamps);
  $count = count($timestamps) - 1;
  $diff = 0;

  for ($i = 0; $i < $count; $i++) {
    $diff += $timestamps[$i + 1] - $timestamps[$i];
  }

  return $count > 0 ? round($diff / $count) : 0;
}

/**
 * Check if there is a visible sitemap link given a certain set of conditions.
 *
 * @param $conditions
 *   An array of values to match keyed by field.
 * @param $flag
 *   An optional boolean that if TRUE, will set the regenerate needed flag if
 *   there is a match. Defaults to FALSE.
 * @return
 *   TRUE if there is a visible link, or FALSE otherwise.
 */
function _xmlsitemap_check_changed_links(array $conditions = array(), array $updates = array(), $flag = FALSE) {
  // If we are changing status or access, check for negative current values.
  $conditions['status'] = (!empty($updates['status']) && empty($condition['status'])) ? 0 : 1;
  $conditions['access'] = (!empty($updates['access']) && empty($condition['access'])) ? 0 : 1;

  $query = db_select('xmlsitemap');
  $query->addExpression('1');
  foreach ($conditions as $field => $value) {
    $query->condition($field, $value);
  }
  $query->range(0, 1);
  $changed = $query->execute()->fetchField();

  if ($changed && $flag) {
    variable_set('xmlsitemap_regenerate_needed', TRUE);
  }

  return $changed;
}

/**
 * Check if there is sitemap link is changed from the existing data.
 *
 * @param $link
 *   An array of the sitemap link.
 * @param $original_link
 *   An optional array of the existing data. This should only contain the
 *   fields necessary for comparison. If not provided the existing data will be
 *   loaded from the database.
 * @param $flag
 *   An optional boolean that if TRUE, will set the regenerate needed flag if
 *   there is a match. Defaults to FALSE.
 * @return
 *   TRUE if the link is changed, or FALSE otherwise.
 */
function _xmlsitemap_check_changed_link(array $link, $original_link = NULL, $flag = FALSE) {
  $changed = FALSE;

  if ($original_link === NULL) {
    // Load only the fields necessary for data to be changed in the sitemap.
    $original_link = db_query_range("SELECT loc, access, status, lastmod, priority, changefreq, changecount, language FROM {xmlsitemap} WHERE type = :type AND id = :id", 0, 1, array(':type' => $link['type'], ':id' => $link['id']))->fetchAssoc();
  }

  if (!$original_link) {
    if ($link['access'] && $link['status']) {
      // Adding a new visible link.
      $changed = TRUE;
    }
  }
  else {
    if (!($original_link['access'] && $original_link['status']) && $link['access'] && $link['status']) {
      // Changing a non-visible link to a visible link.
      $changed = TRUE;
    }
    elseif ($original_link['access'] && $original_link['status'] && array_diff_assoc($original_link, $link)) {
      // Changing a visible link
      $changed = TRUE;
    }
  }

  if ($changed && $flag) {
    variable_set('xmlsitemap_regenerate_needed', TRUE);
  }

  return $changed;
}

/**
 * Load a specific sitemap link.
 *
 * @param $conditions
 *   An array of values to match keyed by field.
 * @return
 *   An array representing the first sitemap link matching the conditions found.
 *
 * @todo Convert to use $type and $id as parameters.
 */
function xmlsitemap_load_link(array $conditions) {
  $query = db_select('xmlsitemap', 'x');
  $query->fields('x');
  foreach ($conditions as $field => $value) {
    $query->condition($field, $value);
  }
  $query->range(0, 1);
  $link = $query->execute()->fetchAssoc();

  // Allow other modules to respond after loading the link.
  //module_invoke_all('xmlsitemap_load_link', $link, $conditions, $args);

  return $link;
}

/**
 * Saves or updates a sitemap link.
 *
 * @param $link
 *   An array with a sitemap link.
 */
function xmlsitemap_save_link(array $link) {
  $link += array(
    'access' => 1,
    'status' => 1,
    'status_override' => 0,
    'lastmod' => 0,
    'priority' => 0.5,
    'priority_override' => 0,
    'changefreq' => 0,
    'changecount' => 0,
    'language' => LANGUAGE_NONE,
  );

  // Allow other modules to alter the link before saving.
  drupal_alter('xmlsitemap_link', $link);

  // Temporary validation checks.
  // @todo Remove in final?
  if ($link['priority'] < 0 || $link['priority'] > 1) {
    trigger_error(t('Invalid sitemap link priority %priority.<br />@link', array('%priority' => $link['priority'], '@link' => var_export($link, TRUE))), E_USER_ERROR);
  }
  if ($link['changecount'] < 0) {
    trigger_error(t('Negative changecount value. Please report this to <a href="@516928">@516928</a>.<br />@link', array('@516928' => 'http://drupal.org/node/516928', '@link' => var_export($link, TRUE))), E_USER_ERROR);
    $link['changecount'] = 0;
  }

  $existing = db_query_range("SELECT loc, access, status, lastmod, priority, changefreq, changecount, language FROM {xmlsitemap} WHERE type = :type AND id = :id", 0, 1, array(':type' => $link['type'], ':id' => $link['id']))->fetchAssoc();

  // Check if this is a changed link and set the regenerate flag if necessary.
  if (!variable_get('xmlsitemap_regenerate_needed', FALSE)) {
    _xmlsitemap_check_changed_link($link, $existing, TRUE);
  }

  if ($existing) {
    drupal_write_record('xmlsitemap', $link, array('type', 'id'));
  }
  else {
    drupal_write_record('xmlsitemap', $link);
  }

  // Allow other modules to respond after saving the link.
  //module_invoke_all('xmlsitemap_save_link', $link);

  return $link;
}

/**
 * Perform a mass update of sitemap data.
 *
 * If visible links are updated, this will automatically set the regenerate
 * needed flag to TRUE.
 *
 * @param $updates
 *   An array of values to update fields to, keyed by field name.
 * @param $conditions
 *   An array of values to match keyed by field.
 * @return
 *   The number of links that were updated.
 */
function xmlsitemap_update_links($updates = array(), $conditions = array()) {
  // If we are going to modify a visible sitemap link, we will need to set
  // the regenerate needed flag.
  if (!variable_get('xmlsitemap_regenerate_needed', FALSE)) {
    _xmlsitemap_check_changed_links($conditions, $updates, TRUE);
  }

  // Process updates.
  $query = db_update('xmlsitemap');
  $query->fields($updates);
  foreach ($conditions as $field => $value) {
    $query->condition($field, $value);
  }

  return $query->execute();
}

/**
 * Delete one or more sitemap links.
 *
 * If a visible sitemap link was deleted, this will automatically set the
 * regenerate needed flag.
 *
 * @param $conditions
 *   An array of values to match keyed by field.
 * @return
 *   The number of links that were deleted.
 */
function xmlsitemap_delete_link(array $conditions) {
  if (!variable_get('xmlsitemap_regenerate_needed', TRUE)) {
    _xmlsitemap_check_changed_links($conditions, array(), TRUE);
  }

  $query = db_delete('xmlsitemap');
  foreach ($conditions as $field => $value) {
    $query->condition($field, $value);
  }

  return $query->execute();
}

/**
 * Get the filename of a specific sitemap page chunk.
 *
 * @param $chunk
 *   An integer representing the integer of the sitemap page chunk.
 * @param $language
 *   A string with a language code.
 * @return
 *   A file path to the expected chunk file.
 *
 * @todo Move to xmlsitemap.inc
 */
function xmlsitemap_get_chunk_file($chunk = 0, $language = LANGUAGE_NONE, $extension = 'xml') {
  return xmlsitemap_get_directory() . "/xmlsitemap-{$language}-{$chunk}.{$extension}";
}

/**
 * Implements hook_form_alter().
 *
 * Set the regeneration needed flag if settings are changed.
 */
function xmlsitemap_form_alter(&$form, $form_state, $form_id) {
  $forms = array(
    'locale_languages_overview_form', // Language settings
    'xmlsitemap_settings_form', // XML sitemap settings
  );
  if (in_array($form_id, $forms)) {
    array_unshift($form['#submit'], 'xmlsitemap_form_submit_flag_regenerate');
  }
}

/**
 * Submit handler; Set the regenerate needed flag if variables have changed.
 *
 * This function needs to be called before system_settings_form_submit() or any
 * calls to variable_set().
 */
function xmlsitemap_form_submit_flag_regenerate($form, $form_state) {
  foreach ($form_state['values'] as $variable => $value) {
    $stored_value = variable_get($variable, 'not_a_variable');
    if (is_array($value) && !empty($form_state['values']['array_filter'])) {
      $value = array_keys(array_filter($value));
    }
    if ($stored_value != 'not_a_variable' && $stored_value != $value) {
      variable_set('xmlsitemap_regenerate_needed', TRUE);
      drupal_set_message(t('XML sitemap settings have been modified and the files should be regenerated. You can <a href="@run-cron">run cron manually</a> to regenerate the cached files.', array('@run-cron' => url('admin/reports/status/run-cron', array('query' => drupal_get_destination())))), 'warning', FALSE);
      return;
    }
  }
}

/**
 * Internal default variables for xmlsitemap_var().
 */
function xmlsitemap_variables() {
  return array(
    'xmlsitemap_rebuild_needed' => FALSE,
    'xmlsitemap_regenerate_needed' => FALSE,
    'xmlsitemap_generated_last' => 0,
    'xmlsitemap_minimum_lifetime' => 0,
    'xmlsitemap_xsl' => TRUE,
    'xmlsitemap_languages' => array(language_default('language')),
    'xmlsitemap_chunk_size' => 'auto',
    'xmlsitemap_batch_limit' => 100,
    'xmlsitemap_path' => 'xmlsitemap',
    'xmlsitemap_base_url' => $GLOBALS['base_url'],
    'xmlsitemap_developer_mode' => FALSE,
    'xmlsitemap_frontpage_priority' => '1.0',
    'xmlsitemap_frontpage_changefreq' => XMLSITEMAP_FREQUENCY_DAILY,
    // Removed variables are set to NULL so they can still be deleted.
    'xmlsitemap_gz' => FALSE,
    'xmlsitemap_regenerate_last' => NULL,
    'xmlsitemap_custom_links' => NULL,
    'xmlsitemap_priority_default' => NULL,
  );
}

/**
 * Internal implementation of variable_get().
 */
function xmlsitemap_var($name, $default = NULL) {
  $defaults = &drupal_static(__FUNCTION__);
  if (!isset($defaults)) {
    $defaults = xmlsitemap_variables();
  }

  $name = 'xmlsitemap_'. $name;

  // @todo Remove when stable.
  if (!isset($defaults[$name])) {
    trigger_error(strtr('Default variable for %variable not found.', array('%variable' => drupal_placeholder($name))));
  }

  return variable_get($name, isset($default) || !isset($defaults[$name]) ? $default : $defaults[$name]);
}

/**
 * Set the current user stored in $GLOBALS['user'].
 *
 * @todo Remove when http://drupal.org/node/287292 is fixed.
 */
function xmlsitemap_switch_user($new_user = NULL) {
  global $user;
  $user_original = &drupal_static(__FUNCTION__);

  if (!isset($new_user)) {
    if (isset($user_original)) {
      // Restore the original user.
      $user = $user_original;
      $user_original = NULL;
      drupal_save_session(TRUE);
    }
    else {
      return FALSE;
    }
  }
  elseif (is_numeric($new_user) && $user->uid != $new_user) {
    // Get the full user object.
    if (!$new_user) {
      $new_user = drupal_anonymous_user();
    }
    elseif (!$new_user = user_load($new_user)) {
      return FALSE;
    }

    // Backup the original user object.
    if (!isset($user_original)) {
      $user_original = $user;
      drupal_save_session(FALSE);
    }

    $user = $new_user;
  }
  elseif (is_object($new_user) && $user->uid != $new_user->uid) {
    // Backup the original user object.
    if (!isset($user_original)) {
      $user_original = $user;
      drupal_save_session(FALSE);
    }

    $user = $new_user;
  }
  else {
    return FALSE;
  }

  return $user;
}

/**
 * Restore the user that was originally loaded.
 *
 * @return
 *  Current user.
 */
function xmlsitemap_restore_user() {
  return xmlsitemap_switch_user();
}

function xmlsitemap_process_form_link_options($form, &$form_state) {
  $link = &$form_state['values']['xmlsitemap'];
  $fields = array('status' => 1, 'priority' => 0.5);

  foreach ($fields as $field => $default) {
    if ($link[$field] === 'default') {
      $link[$field] = isset($link[$field . '_default']) ? $link[$field . '_default'] : $default;
      $link[$field . '_override'] = 0;
    }
    else {
      $link[$field . '_override'] = 1;
    }
  }
}

/**
 * @todo Document this function.
 * @todo Make these translatable
 */
function xmlsitemap_get_changefreq_options() {
  return array(
    XMLSITEMAP_FREQUENCY_ALWAYS => 'always',
    XMLSITEMAP_FREQUENCY_HOURLY => 'hourly',
    XMLSITEMAP_FREQUENCY_DAILY => 'daily',
    XMLSITEMAP_FREQUENCY_WEEKLY => 'weekly',
    XMLSITEMAP_FREQUENCY_MONTHLY => 'monthly',
    XMLSITEMAP_FREQUENCY_YEARLY => 'yearly',
  );
}

/**
 * Returns information about supported sitemap link types.
 *
 * @param $type
 *   (optional) The link type to return information for. If omitted,
 *   information for all link types is returned.
 * @param $reset
 *   (optional) Boolean whether to reset the static cache and do nothing. Only
 *   used for tests.
 *
 * @see hook_xmlsitemap_link_info()
 * @see hook_xmlsitemap_link_info_alter()
 */
function xmlsitemap_get_link_info($type = NULL) {
  global $language;
  $link_info = &drupal_static(__FUNCTION__);

  if (!isset($link_info)) {
    if ($cached = cache_get('xmlsitemap:link_info:' . $language->language)) {
      $link_info = $cached->data;
    }
    else {
      $link_info = array();
      foreach (module_implements('xmlsitemap_link_info') as $module) {
        $module_link_info = module_invoke($module, 'xmlsitemap_link_info');
        foreach ($module_link_info as $type => $info) {
          $module_link_info[$type] += array(
            'type' => $type,
            'module' => $module,
            'purge' => TRUE,
            'table' => FALSE,
          );
        }
        $link_info = array_merge($link_info, $module_link_info);
      }
      drupal_alter('xmlsitemap_link_info', $link_info);
      cache_set('xmlsitemap:link_info:' . $language->language, $link_info);
    }
  }

  if (isset($type)) {
    return isset($link_info[$type]) ? $link_info[$type] : NULL;
  }

  return $link_info;
}

/**
 * Implements hook_xmlsitemap_link_info().
 */
function xmlsitemap_xmlsitemap_link_info() {
  return array(
    'frontpage' => array(),
  );
}

function xmlsitemap_get_directory() {
  $directory = &drupal_static(__FUNCTION__);

  if (!isset($directory)) {
    $directory = file_directory_path() . '/' . variable_get('xmlsitemap_path', 'xmlsitemap');
  }

  return $directory;
}

/**
 * Check that the sitemap files directory exists and is writable.
 */
function xmlsitemap_check_directory() {
  $directory = xmlsitemap_get_directory();
  $result = file_prepare_directory($directory, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS);
  if (!$result) {
    watchdog('file system', 'The directory %directory does not exist or is not writable.', array('%directory' => $directory), WATCHDOG_ERROR);
  }
  return $result;
}

function xmlsitemap_clear_directory($delete = FALSE) {
  $directory = xmlsitemap_get_directory();
  return _xmlsitemap_delete_recursive($directory, $delete);
}

function _xmlsitemap_delete_recursive($path, $delete_root = FALSE) {
  // Resolve streamwrapper URI to local path.
  $path = drupal_realpath($path);
  if (is_dir($path)) {
    $dir = dir($path);
    while (($entry = $dir->read()) !== FALSE) {
      if ($entry == '.' || $entry == '..') {
        continue;
      }
      $entry_path = $path . '/' . $entry;
      file_unmanaged_delete_recursive($entry_path, TRUE);
    }
    $dir->close();
    return $delete_root ? rmdir($path) : TRUE;
  }
  return file_unmanaged_delete($path);
}

/**
 * Load a language object by its language code.
 *
 * @todo Remove when http://drupal.org/node/660736 is fixed in Drupal core.
 *
 * @param $language
 *   A language code. If not provided the default language will be returned.
 * @return
 *   A language object.
 */
function xmlsitemap_language_load($language = LANGUAGE_NONE) {
  $languages = &drupal_static(__FUNCTION__);

  if (!isset($languages)) {
    $languages = language_list();
    $languages[LANGUAGE_NONE] = NULL;
  }

  return $languages[$language];
}
