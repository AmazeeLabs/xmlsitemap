<?php
// $Id$

/**
 * Implements hook_entity_info_alter().
 */
function xmlsitemap_node_entity_info_alter(&$entity_info) {
  $entity_info['node']['label'] = t('Content');
  $entity_info['node']['bundle label'] = t('Content type');
  $entity_info['node']['xmlsitemap'] = array();
  foreach (node_type_get_names() as $type => $name) {
    $entity_info['node']['bundles'][$type]['xmlsitemap'] = array(
      'priority' => variable_get('xmlsitemap_node_priority_' . $type, 0.5),
      'status' => variable_get('xmlsitemap_node_status_' . $type, 0),
    );
  }
}

/**
 * Implements hook_cron().
 *
 * Process old nodes not found in the {xmlsitemap} table.
 */
function xmlsitemap_node_cron() {
  xmlsitemap_node_xmlsitemap_index_links(xmlsitemap_var('batch_limit'));
}

/**
 * Implements hook_xmlsitemap_index_links().
 */
function xmlsitemap_node_xmlsitemap_index_links($limit) {
  if ($types = xmlsitemap_node_get_types()) {
    $nids = db_query_range("SELECT n.nid FROM {node} n LEFT JOIN {xmlsitemap} x ON x.type = 'node' AND n.nid = x.id WHERE x.id IS NULL AND n.type IN (:types) ORDER BY n.nid DESC", 0, $limit, array(':types' => $types))->fetchCol();
    $nodes = node_load_multiple($nids);
    foreach ($nodes as $node) {
      $link = xmlsitemap_node_create_link($node);
      xmlsitemap_save_link($link);
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function xmlsitemap_node_node_insert($node) {
  xmlsitemap_node_node_update($node);
}

/**
 * Implements hook_node_update().
 */
function xmlsitemap_node_node_update($node) {
  $link = xmlsitemap_node_create_link($node);
  xmlsitemap_save_link($link);
}

/**
 * Implements hook_node_delete().
 */
function xmlsitemap_node_node_delete($node) {
  xmlsitemap_link_delete('node', $node->nid);
}

/**
 * Implements hook_comment_update().
 */
function xmlsitemap_node_comment_update(stdClass $comment) {
  if ($node = node_load($comment->nid, NULL, TRUE)) {
    xmlsitemap_node_node_update($node);
  }
}

/**
 * Implements hook_comment_publish().
 */
function xmlsitemap_node_comment_publish(stdClass $comment) {
  xmlsitemap_node_comment_update($comment);
}

/**
 * Implements hook_comment_unpublish().
 */
function xmlsitemap_node_comment_unpublish(stdClass $comment) {
  xmlsitemap_node_comment_update($comment);
}

/**
 * Implements hook_comment_delete().
 */
function xmlsitemap_node_comment_delete(stdClass $comment) {
  xmlsitemap_node_comment_update($comment);
}

/**
 * Implements hook_node_type_delete().
 */
function xmlsitemap_node_node_type_delete($info) {
  variable_del('xmlsitemap_node_status_' . $info->type);
  variable_del('xmlsitemap_node_priority_' . $info->type);
  //xmlsitemap_link_delete_multiple(array('type' => 'node', 'subtype' => $info->type));
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @see node_type_form()
 * @see xmlsitemap_add_form_type_options()
 */
function xmlsitemap_node_form_node_type_form_alter(&$form, $form_state) {
  $node_type = isset($form['#node_type']->type) ? $form['#node_type']->type : '';

  module_load_include('inc', 'xmlsitemap', 'xmlsitemap.admin');
  $options = array(
    'status' => variable_get('xmlsitemap_node_status_' . $node_type, 0),
    'priority' => variable_get('xmlsitemap_node_priority_' . $node_type, 0.5),
  );
  xmlsitemap_add_form_type_options($form, 'node', $options);
  $form['xmlsitemap']['#attached']['js']['vertical-tabs'] = drupal_get_path('module', 'xmlsitemap_node') . '/xmlsitemap_node.js';

  // Add our submit handler before node_type_form_submit() so we can compare
  // the old and new values.
  array_unshift($form['#submit'], 'xmlsitemap_node_type_form_submit');
}

function xmlsitemap_node_type_form_submit($form, $form_state) {
  $node_type = $form_state['values']['old_type'];
  $new_status = $form_state['values']['xmlsitemap_node_status'];
  $new_priority = $form_state['values']['xmlsitemap_node_priority'];
  $new_type = $form_state['values']['type'];

  if ($new_status != variable_get('xmlsitemap_node_status_' . $node_type, 0)) {
    xmlsitemap_update_links(array('status' => $new_status), array('type' => 'node', 'subtype' => $node_type, 'status_override' => 0));
  }
  if ($new_priority != variable_get('xmlsitemap_node_priority_' . $node_type, 0.5)) {
    xmlsitemap_update_links(array('priority' => $new_priority), array('type' => 'node', 'subtype' => $node_type, 'priority_override' => 0));
  }
  if ($node_type != $new_type) {
    xmlsitemap_update_links(array('subtype' => $new_type), array('type' => 'node', 'subtype' => $node_type));
  }
}

/**
 * Implements hook_form_alter().
 *
 * Add the XML sitemap individual link options for a node.
 *
 * @see xmlsitemap_add_form_link_options()
 */
function xmlsitemap_node_form_alter(&$form, $form_state, $form_id) {
  if (!empty($form['#node_edit_form'])) {
    $node = clone $form['#node'];
    if (!isset($node->nid)) {
      // Handle new nodes that do not have a value for nid yet.
      $node->nid = NULL;
    }
    $link = xmlsitemap_node_create_link($node);

    // Add the link options.
    module_load_include('inc', 'xmlsitemap', 'xmlsitemap.admin');
    xmlsitemap_add_form_link_options($form, $link);

    $form['xmlsitemap']['#access'] |= user_access('administer nodes');
    $form['xmlsitemap']['#weight'] = 30;
    if (user_access('administer content types')) {
      $form['xmlsitemap']['#description'] = t('The default XML sitemap settings for this content type can be changed <a href="@link-type">here</a>.', array('@link-type' => url('admin/structure/types/manage/' . str_replace('_', '-', $node->type), array('query' => drupal_get_destination()))));
    }
  }
}

/**
 * Implements hook_xmlsitemap_links().
 */
function xmlsitemap_node_xmlsitemap_links($offset = 0, $limit = 0) {
  $links = array();

  if ($types = xmlsitemap_node_get_types()) {
    $sql = "SELECT n.nid FROM {node} n WHERE n.nid > :offset AND n.type IN (:types) ORDER BY n.nid";
    $args = array(':offset' => $offset, ':types' => $types);
    $nids = ($limit ? db_query_range($sql, 0, $limit, $args)->fetchCol() : db_query($sql, $args)->fetchCol());
    $nodes = node_load_multiple($nids);

    foreach ($nodes as $node) {
      $links[] = xmlsitemap_node_create_link($node);
    }
  }

  return $links;
}

/**
 * Implements hook_xmlsitemap_links_batch_info().
 */
function xmlsitemap_node_xmlsitemap_links_batch_info() {
  $types = xmlsitemap_node_get_types();
  return array(
    'max' => $types ? db_query("SELECT COUNT(n.nid) FROM {node} n WHERE n.type IN (:types)", array(':types' => $types))->fetchField() : 0,
  );
}

/**
 * Fetch an array of node types to be included in the sitemap.
 */
function xmlsitemap_node_get_types() {
  $node_types = array_keys(node_type_get_names());
  foreach ($node_types as $index => $node_type) {
    if (!variable_get('xmlsitemap_node_status_' . $node_type, 0)) {
      unset($node_types[$index]);
    }
  }
  return $node_types;
}

/**
 * Implements hook_field_extra_fields().
 */
function xmlsitemap_node_field_extra_fields() {
  $extras = array();
  foreach (xmlsitemap_node_get_types() as $type) {
    $extras['node'][$type]['xmlsitemap'] = array(
      'label' => t('XML sitemap'),
      'description' => t('XML sitemap module element'),
      'weight' => 30,
    );
  }
  return $extras;
}

/**
 * Fetch all the timestamps for when a node was changed.
 *
 * @param $node
 *   A node object.
 * @return
 *   An array of UNIX timestamp integers.
 */
function xmlsitemap_node_get_timestamps($node) {
  static $timestamps = array();

  if (!isset($timestamps[$node->nid])) {
    $timestamps[$node->nid] = db_query("SELECT c.created FROM {comment} c WHERE c.nid = :nid AND c.status = :status UNION ALL SELECT nr.timestamp FROM {node_revision} nr WHERE nr.nid = :nid2", array(':nid' => $node->nid, ':status' => COMMENT_PUBLISHED, ':nid2' => $node->nid))->fetchCol();
  }

  return $timestamps[$node->nid];
}

/**
 * Create a sitemap link from a node.
 *
 * The link will be saved as $node->xmlsitemap.
 *
 * @param $node
 *   A node object.
 */
function xmlsitemap_node_create_link(&$node) {
  if (!isset($node->xmlsitemap) || !is_array($node->xmlsitemap)) {
    $node->xmlsitemap = array();
    if ($node->nid && $link = xmlsitemap_link_load('node', $node->nid)) {
      $node->xmlsitemap = $link;
    }
  }

  $node->xmlsitemap += array(
    'type' => 'node',
    'id' => $node->nid,
    'subtype' => $node->type,
    'loc' => 'node/'. $node->nid,
    'status' => variable_get('xmlsitemap_node_status_' . $node->type, 0),
    'status_default' => variable_get('xmlsitemap_node_status_' . $node->type, 0),
    'status_override' => 0,
    'priority' => variable_get('xmlsitemap_node_priority_' . $node->type, 0.5),
    'priority_default' => variable_get('xmlsitemap_node_priority_' . $node->type, 0.5),
    'priority_override' => 0,
  );

  // Always recalculate changefreq and changecount.
  $timestamps = xmlsitemap_node_get_timestamps($node);
  $node->xmlsitemap['changefreq'] = $node->nid ? xmlsitemap_calculate_changefreq($timestamps) : 0;
  $node->xmlsitemap['changecount'] = $node->nid ? count($timestamps) - 1 : 0;

  // Node access must be reset since it a user may have changed published status, etc.
  $access = &drupal_static('node_access');
  unset($access[0][$node->nid]);
  //node_access_acquire_grants($node);

  // The following values must always be checked because they are volatile.
  $node->xmlsitemap['lastmod'] = isset($node->changed) ? $node->changed : REQUEST_TIME;
  $node->xmlsitemap['access'] = $node->nid ? (bool) node_access('view', $node, drupal_anonymous_user()) : 1;
  $node->xmlsitemap['language'] = isset($node->language) ? $node->language : LANGUAGE_NONE;

  return $node->xmlsitemap;
}

/**
 * Internal default variables for xmlsitemap_node_var().
 */
function xmlsitemap_node_variables() {
  $defaults = array();
  $node_types = array_keys(node_type_get_names());
  foreach ($node_types as $node_type) {
    $defaults['xmlsitemap_node_priority_' . $node_type] = 0.5;
    $defaults['xmlsitemap_node_status_' . $node_type] = 0;
    // @todo Remove the variable.
    $defaults['xmlsitemap_node_update_' . $node_type] = NULL;
  }
  return $defaults;
}
